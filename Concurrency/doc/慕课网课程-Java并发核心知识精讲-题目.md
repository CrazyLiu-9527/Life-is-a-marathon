## 1、有多少种实现线程的方法？典型错误答案和正确答案（对应视频3-1~3-3、3.6）
答题思路，以下5点：
1. 从不同的角度看，会有不同的答案。
2. 典型答案是两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；
3. 但是，我们看原理，其实Thread类实现Runnable接口，并且看Thread类的run方法，会发现其实两种方法的本质都是一样的，run方法的代码如下：

```java
@Override
public void run() {
    if(target != null) {
        target.run();
    }
}
```

​		方法一和方法二，也就是**继承Thread类然后重写run**和**实现Runnable接口并传入Thread类**在实现多线程的本质上，并没有区别，都是最终调用了start()方法来创建新线程。这两个方法的区别在于run()方法的来源：

> 方法一：最终调用target.run()；
>
> 方法二：run()整个都被重写；

4. 然后具体展开说其它方式：还有其他实现线程的方式，比如线程池、定时器。他们也能创建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。
5. 结论：我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现第一种是重写run方法，第二种是实现Runnable接口的run方法，然后把该runnable实例传给Threa类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程，但是他们的本质都逃不出刚才所说的范围。

以上这种描述比直接回答一种、两种、多种都更准确。



## 2、实现Runnable接口和继承Thread类哪种方式更好？（对应视频3-2）

### 1、实现Runnable接口更好

1.  从代码架构角度：**具体的任务（run方法）**应该和创**建运行线程的机制（Thread类）**解耦，用runnable对象可以**实现解耦**。通过Runnable方式实现的run方法中的内容就是具体执行的任务，可以让一个单独任务类实现Runnable接口，然后把对应的实例传入Thread类就可以。这样的话，同样一个任务类，可以传给不同的Thread，并且任务类也不负责创建线程等工作，是解耦的。
2. 使用Thread的方式的恶化，那么每次想要新建一个任务，只能新建一个独立的线程，而这样做的损耗会比较大（比如重头开始创建一个线程、执行完毕之后再销毁等。如果线程的实际工作内容也就是run()方法只是简单打印一行文字的话，那么可能现成的工作内容还不如损耗来的大）。如果使用Runnable和线程池，就可以大大减小这样的损耗。
3. 继承Thread类之后，由于Java语言不支持多继承，这样就无法再继承其它的类，限制了可扩展性。

> 通常我们优先选择实现Runnable接口。
>
> 继承Thread类也会有几个小小的好处，但是相比于缺点来说的话，不值一提。比如
>
> 1. run()方法内获取当前线程可以直接使用this，而无需用Thread.currentThread()方法；
> 2. 继承的类内部变量不会直接共享，少数不需要共享变量的场景下使用起来会更方便；

### 2、两种方法的本质对比

方法一和方法二，也就是**继承Thread类然后重写run**和**实现Runnable接口并传入Thread类**在实现多线程的本质上，并没有区别，都是最终调用了start()方法来创建新线程。这两个方法的区别在于run()方法的来源：

```java
@Override
public void run() {
    if(target != null) {
        target.run();
    }
}
```

> 方法一：最终调用target.run()；
>
> 方法二：run()整个都被重写；



## 3、一个线程调用两次start方法会出现什么情况？为什么？（对应视频4-2、4-5）

### 1、让我们一起来看下start()的源码

```java
public synchronized void start() {
        
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    group.add(this);

    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
        }
    }
}

private native void start0();
```

### 2、流程

1. 检查流程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行中活着已结束的线程，都不能再次启动，详见代码中的CantStartTwice类）；
2. 被加入线程组；
3. 调用start0()方法启动线程；

> 注意点：
>
> 1. start方法是被synchronized修饰的方法，可以保证线程安全；
> 2. 由JVM创建的main方法线程和system组线程，并不会通过start来启动；

### 3、解答

丛源码可以看出，start的时候会先检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException。

### 4、既然Thread.start()只能调用一次。那么线程池是如何实现复用的呢?

线程重用的核心是，线程池对Thread做了包装，不重读调用thread.start()，而是自己有一个Runnable.run()，run方法里面循环在跑，跑的过程中不断检查我们是否有新加入的子Runnable对象，有新的Runnable进来的话就调一下我们的run()，其实就是一个大run()把其它小run()#1、run()#1、...给串联起来了。同一个Thread可以执行不同的Runnable，主要原因是线程池吧线程和Runnabel通过BlokingQueue给解耦了，线程可以从BlokingQueue中不断的获取新的任务。



## 4、既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？（对应视频4-5）

start()才是真正启动一个线程，而如果直接调用run()，那么run只是一个普通的方法而已，和线程的生命周期没有任何关系。



## 5、如何正确停止一个线程？（对应视频5-6、5-7、5-15）

1. **原理**：用interrupt来请求线程停止而不是强制，好处是安全；
2. **三方配合**：想停止线程，要请求方、被停止方、子方法被调用放方相互配合才行；
   1. **被停止方**：每次循环中或者适时检查中断信号，并且在可能抛出InterruptException的地方处理该中断信号；
   2. **请求方**：发出中断信号；
   3. **子方法调用方（被线程调用的方法的作者）**：优先在方法层面抛出InterruptException，或者检查到中断信号时，再次设置中断状态；
3. 最后再说**错误的方法**：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况；



## 6、如何处理不可中断的阻塞（例如抢锁时ReentrantLock.lock()或者Socket I/O时无法响应中断应该怎么让该线程停止呢？）（对应视频5-15）

如果线程阻塞是由于调用了wait()、sleep()或者join()方法，你可以中断线程，通过抛出InterruptException异常来唤醒线程。

但是对于不能响应InterruptException的阻塞，很遗憾，并没有一个通用的解决方案。

但是我们可以利用特定的其它可以响应中断的方法，比如ReentrantLock.lockInterruptibly()，比如关闭套接字使线程立即返回等方法来达到目的。

答案有很多种，因为有很多原因会造成阻塞，所以针对不同情卡U那个，唤起的方法也不同。



总结来说就是如果不支持响应中断，就要用特定的方法来唤起，没有万能药。



## 7、线程有哪几种状态？声明周期是什么？（对应视频6-1、6-2、6-5）

![img](https://qqadapt.qpic.cn/txdocpic/0/b61469191f025091ea807272617866bc/0?_type=png)

图中共有3点需要说明：状态、路径、转换条件。

### 1、六种状态

```Java
NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED
```

### 2、转换关系

1. 新创建线程只能往下走到可运行，而不能直接跳跃到其它状态；
2. 线程生命周期不可回头：一旦到了可运行就不能回到新创建，一旦被终止，就不能再有任何状态的变化了。所以一个线程只能有一次的新创建和已终止。线程是不可以重重复执行的，当它运行完了之后便会结束，一单一个线程进入了TERMINATED状态，它便不可以重新变回RUNNABLE等状态，这个不可重复执行的性质和线程池是一样的。如果我们还想执行该任务，可以选择重新创建一个线程，而原对象会被JVM回收。

### 3、转化条件

详见状态转移图。

### 4、特殊情况

1. 如果发生异常，可以直接跳到终止TERMINATED状态，不必再遵循路径，比如可以WAITING直接到TERMINATED；
2. 从Object.wait()刚被唤醒时，通常不能立即抢到monitor锁，那就会从WAITING先进入BLOCKED状态，抢到锁后再转换到RUNNABLE状态；

wait相关状态转移图如下：

![img](https://qqadapt.qpic.cn/txdocpic/0/134cbc6dd6198cf573fcfdfa31a23954/0)

### 5、线程状态官方文档

https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Thread.State.html

### 6、各个状态的代码演示

详见包`package per.lzy.concurrencuylearning.core.sixstate_04`。



## 8、如何用wait()实现两个线程交替打印0-100的奇偶数？（对应视频7-7）

### 1、问题描述

两个线程，一个线程打印奇数另一个打印偶数，它们交替输出，如下所示：

> 偶线程：0
>
> 奇线程：1
>
> 偶线程：2
>
> ......
>
> 奇线程：99
>
> 偶线程：100

### 2、解题思路

#### 1. 用synchronized实现

比较容易想到的一个方案是，要输出的时候判断一下当前需要输出的数是不是自己要负责打印的值，如果是就输出，如果不是就直接释放锁。代码详见文件`WaitNotifyPrintOddEvenSyn.java`。

这个方法可以满足题目的要求：两个线程，一个打印奇数，一个打印偶数，轮流输出。但是只用了一个讨巧的方式避开了线程交替获取锁的需求，明显没有答到面试官考察的点上。而且效率较低，如果同一个线程一直抢到锁，而另一个线程一直没有拿到，就会导致线程做很多无谓的空转。那么有没有更好的解决方案，让两个线程严格的交替获取到锁呢？

> 注意：这里的synchronized的锁对象不应该用count变量，因为该变量执行了count++之后，count所指向的对象地址已经变了。

#### 2. 更好的方法：wait/notify

交替获取锁的方案：这种实现方式的原理就是线程1打印之后唤醒线程2，然后让出锁，自己进入休眠状态。因为进入了休眠状态就不会与线程2抢锁，此时只有线程2在获取锁，所以线程2必然会拿到锁。线程2以同样的逻辑执行，唤醒线程1并让出自己持有的锁，自己进入休眠状态。这样来来回回，持续执行直到任务完。代码详见文件`WaitNotifyPrintOddEveWait.java`。



## 9、如何用wait()实现生产者模式？（对应视频7-6）

## 10、为什么wait()必须在同步代码块中使用？（对应视频7-8）

## 11、为什么线程通信方法wait()/notify()/notifyAll()定义在Object类中？而sleep定义在Thread类里？（对应视频7-8）

## 12、wait方法是属于Object对象的，那么调用Thread.wati()会怎么样？（对应视频7-8）

## 13、如何选择用notify还是notifyAll？（对应视频7-3）

## 14、notifyAll之后所有的线程都会再次抢夺锁，那么某个线程抢夺失败怎么办？（对应视频7-8）

## 15、用suspend()和resume()来阻塞线程可以吗？为什么？（对应视频7-8）

## 16、wait/notify、sleep的异同（方法属于哪个对象？线程状态怎么切换？）？（对应视频7-11）

## 17、在join期间，线程处于那种线程状态？（对应视频7-13）

## 18、yield和sleep的区别？（对应视频7-15）

## 19、守护线程和普通线程的区别？（对应视频8-3）

## 20、我们是否需要给线程设置为守护线程？（对应视频8-3）

## 21、为什么程序设计不依赖于线程优先级？（对应视频8-4）

## 22、讲讲Java异常体系？（对应视频5-9）

## 23、实际工作中，如何处理全局异常？（对应视频9-3）

## 24、为什么异常需要全局处理？不处理行不行？（对应视频9-3）

## 25、run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？（对应视频9-1）

## 26、一共有哪几种线程安全问题？（对应视频10-3、10-6~10-12）

## 27、哪些场景需要额外注意线程安全问题？（对应视频10-13）

## 28、为什么多线程会带来性能问题？（对应视频10-14）

## 29、什么是多线程的上下文切换？（对应视频10-14）

## 30、Java代码如何一步步转换，最终被cpu执行？（对应视频12-3）

## 31、单例模式的作用和适用场景？（对应视频13-9~13-13）

## 32、重排序的实例：单例模式多种写法、单例和高并发的关系（重要，真实面试高频考题，重点双重检查模式的volatile）？（对应视频13-11）

## 33、单例模式各种写法的适用场景？（对应视频13-13）

## 34、饿汉式的缺点？（对应视频13-13）

## 35、懒汉式的缺点？（对应视频13-13）

## 36、为什么要用double-check？不用就不安全吗？（对应视频13-11）

## 37、为什么双重检查模式要用volatile？（对应视频13-11）

## 38、应该如何选择，用哪种单例的实现方方案最好？（对应视频13-13）

## 39、讲一讲什么事Java内存模型？（对应视频12、13章）

## 40、什么事happens-before？（对应视频12-13~12-15）

## 41、Happens-before规则有哪些？（对应视频12-14）

## 42、讲讲volatile关键字？（对应视频13-1~13-5）

## 43、volatile和synchronized的异同？（对应视频13-5）

## 44、什么是内存可见性问题？（对应视频12-9~12-11）

## 45、主内存和本地内存的关系？（对应视频12-12）

## 46、什么是原子操作？（对应视频13-7）

## 47、Java中的原子操作有哪些？（对应视频13-7）

## 48、long和double的原子性你了解吗？（对应视频13-8）

## 49、生成对象的过程是不是原子操作？（对应视频13-11）

## 50、写一个必然死锁的例子？（对应视频14-5）

## 51、生产中什么场景下会发生死锁？（对应视频14-6、14-7）

## 52、发生死锁必然满足哪些条件？（对应视频14-8）

## 53、如何用工具定位死锁？（对应视频14-9、14-10）

## 54、有哪些解决死锁的策略？（对应视频14-11~14-15）

## 55、讲一讲经典的哲学家就餐问题（经典名称叫刀叉问题、吃面问题）？（对应视频14-12~14-14）

## 56、实际开发中如何避免死锁？（对应视频14-16、14-17）

## 57、什么事活跃性问题？活锁、饥饿和死锁有什么区别？（对应视频14-18~14-21）