## 1、有多少种实现线程的方法？典型错误答案和正确答案（对应视频3-1~3-3、3.6）
答题思路，以下5点：
1. 从不同的角度看，会有不同的答案。
2. 典型答案是两种，分别是实现Runnable接口和继承Thread类，然后具体展开说；
3. 但是，我们看原理，其实Thread类实现Runnable接口，并且看Thread类的run方法，会发现其实两种方法的本质都是一样的，run方法的代码如下：

```java
@Override
public void run() {
    if(target != null) {
        target.run();
    }
}
```

​		方法一和方法二，也就是**继承Thread类然后重写run**和**实现Runnable接口并传入Thread类**在实现多线程的本质上，并没有区别，都是最终调用了start()方法来创建新线程。这两个方法的区别在于run()方法的来源：

> 方法一：最终调用target.run()；
>
> 方法二：run()整个都被重写；

4. 然后具体展开说其它方式：还有其他实现线程的方式，比如线程池、定时器。他们也能创建线程，但是细看源码，从没有逃出过本质，也就是实现Runnable接口和继承Thread类。
5. 结论：我们只能通过新建Thread类这一种方式来创建线程，但是类里面的run方法有两种方式来实现第一种是重写run方法，第二种是实现Runnable接口的run方法，然后把该runnable实例传给Threa类。除此之外，从表面上看线程池、定时器等工具类也可以创建线程，但是他们的本质都逃不出刚才所说的范围。

以上这种描述比直接回答一种、两种、多种都更准确。



## 2、实现Runnable接口和继承Thread类哪种方式更好？（对应视频3-2）

### 1、实现Runnable接口更好

1.  从代码架构角度：**具体的任务（run方法）**应该和创**建运行线程的机制（Thread类）**解耦，用runnable对象可以**实现解耦**。通过Runnable方式实现的run方法中的内容就是具体执行的任务，可以让一个单独任务类实现Runnable接口，然后把对应的实例传入Thread类就可以。这样的话，同样一个任务类，可以传给不同的Thread，并且任务类也不负责创建线程等工作，是解耦的。
2. 使用Thread的方式的恶化，那么每次想要新建一个任务，只能新建一个独立的线程，而这样做的损耗会比较大（比如重头开始创建一个线程、执行完毕之后再销毁等。如果线程的实际工作内容也就是run()方法只是简单打印一行文字的话，那么可能现成的工作内容还不如损耗来的大）。如果使用Runnable和线程池，就可以大大减小这样的损耗。
3. 继承Thread类之后，由于Java语言不支持多继承，这样就无法再继承其它的类，限制了可扩展性。

> 通常我们优先选择实现Runnable接口。
>
> 继承Thread类也会有几个小小的好处，但是相比于缺点来说的话，不值一提。比如
>
> 1. run()方法内获取当前线程可以直接使用this，而无需用Thread.currentThread()方法；
> 2. 继承的类内部变量不会直接共享，少数不需要共享变量的场景下使用起来会更方便；

### 2、两种方法的本质对比

方法一和方法二，也就是**继承Thread类然后重写run**和**实现Runnable接口并传入Thread类**在实现多线程的本质上，并没有区别，都是最终调用了start()方法来创建新线程。这两个方法的区别在于run()方法的来源：

```java
@Override
public void run() {
    if(target != null) {
        target.run();
    }
}
```

> 方法一：最终调用target.run()；
>
> 方法二：run()整个都被重写；



## 3、一个线程调用两次start方法会出现什么情况？为什么？（对应视频4-2、4-5）

### 1、让我们一起来看下start()的源码

```java
public synchronized void start() {
        
    if (threadStatus != 0)
        throw new IllegalThreadStateException();

    group.add(this);

    boolean started = false;
    try {
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
        }
    }
}

private native void start0();
```

### 2、流程

1. 检查流程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException（在运行中活着已结束的线程，都不能再次启动，详见代码中的CantStartTwice类）；
2. 被加入线程组；
3. 调用start0()方法启动线程；

> 注意点：
>
> 1. start方法是被synchronized修饰的方法，可以保证线程安全；
> 2. 由JVM创建的main方法线程和system组线程，并不会通过start来启动；

### 3、解答

丛源码可以看出，start的时候会先检查线程状态，只有NEW状态下的线程才能继续，否则会抛出IllegalThreadStateException。

### 4、既然Thread.start()只能调用一次。那么线程池是如何实现复用的呢?

线程重用的核心是，线程池对Thread做了包装，不重读调用thread.start()，而是自己有一个Runnable.run()，run方法里面循环在跑，跑的过程中不断检查我们是否有新加入的子Runnable对象，有新的Runnable进来的话就调一下我们的run()，其实就是一个大run()把其它小run()#1、run()#1、...给串联起来了。同一个Thread可以执行不同的Runnable，主要原因是线程池吧线程和Runnabel通过BlokingQueue给解耦了，线程可以从BlokingQueue中不断的获取新的任务。



## 4、既然start()方法会调用run()方法，为什么我们选择调用start()方法，而不是直接调用run()方法呢？（对应视频4-5）

start()才是真正启动一个线程，而如果直接调用run()，那么run只是一个普通的方法而已，和线程的生命周期没有任何关系。



## 5、如何正确停止一个线程？（对应视频5-6、5-7、5-15）

1. **原理**：用interrupt来请求线程停止而不是强制，好处是安全；
2. **三方配合**：想停止线程，要请求方、被停止方、子方法被调用放方相互配合才行；
   1. **被停止方**：每次循环中或者适时检查中断信号，并且在可能抛出InterruptException的地方处理该中断信号；
   2. **请求方**：发出中断信号；
   3. **子方法调用方（被线程调用的方法的作者）**：优先在方法层面抛出InterruptException，或者检查到中断信号时，再次设置中断状态；
3. 最后再说**错误的方法**：stop/suspend已废弃，volatile的boolean无法处理长时间阻塞的情况；



## 6、如何处理不可中断的阻塞（例如抢锁时ReentrantLock.lock()或者Socket I/O时无法响应中断应该怎么让该线程停止呢？）（对应视频5-15）

如果线程阻塞是由于调用了wait()、sleep()或者join()方法，你可以中断线程，通过抛出InterruptException异常来唤醒线程。

但是对于不能响应InterruptException的阻塞，很遗憾，并没有一个通用的解决方案。

但是我们可以利用特定的其它可以响应中断的方法，比如ReentrantLock.lockInterruptibly()，比如关闭套接字使线程立即返回等方法来达到目的。

答案有很多种，因为有很多原因会造成阻塞，所以针对不同情卡U那个，唤起的方法也不同。



总结来说就是如果不支持响应中断，就要用特定的方法来唤起，没有万能药。



## 7、线程有哪几种状态？声明周期是什么？（对应视频6-1、6-2、6-5）

![img](https://qqadapt.qpic.cn/txdocpic/0/b61469191f025091ea807272617866bc/0?_type=png)

图中共有3点需要说明：状态、路径、转换条件。

### 1、六种状态

```Java
NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED
```

### 2、转换关系

1. 新创建线程只能往下走到可运行，而不能直接跳跃到其它状态；
2. 线程生命周期不可回头：一旦到了可运行就不能回到新创建，一旦被终止，就不能再有任何状态的变化了。所以一个线程只能有一次的新创建和已终止。线程是不可以重重复执行的，当它运行完了之后便会结束，一单一个线程进入了TERMINATED状态，它便不可以重新变回RUNNABLE等状态，这个不可重复执行的性质和线程池是一样的。如果我们还想执行该任务，可以选择重新创建一个线程，而原对象会被JVM回收。

### 3、转化条件

详见状态转移图。

### 4、特殊情况

1. 如果发生异常，可以直接跳到终止TERMINATED状态，不必再遵循路径，比如可以WAITING直接到TERMINATED；
2. 从Object.wait()刚被唤醒时，通常不能立即抢到monitor锁，那就会从WAITING先进入BLOCKED状态，抢到锁后再转换到RUNNABLE状态；

wait相关状态转移图如下：

![img](https://qqadapt.qpic.cn/txdocpic/0/134cbc6dd6198cf573fcfdfa31a23954/0)

### 5、线程状态官方文档

https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Thread.State.html

### 6、各个状态的代码演示

详见包`package per.lzy.concurrencuylearning.core.sixstate_04`。



## 8、如何用wait()实现两个线程交替打印0-100的奇偶数？（对应视频7-7）

### 1、问题描述

两个线程，一个线程打印奇数另一个打印偶数，它们交替输出，如下所示：

> 偶线程：0
>
> 奇线程：1
>
> 偶线程：2
>
> ......
>
> 奇线程：99
>
> 偶线程：100

### 2、解题思路

#### 1. 用synchronized实现

比较容易想到的一个方案是，要输出的时候判断一下当前需要输出的数是不是自己要负责打印的值，如果是就输出，如果不是就直接释放锁。代码详见文件`WaitNotifyPrintOddEvenSyn.java`。

这个方法可以满足题目的要求：两个线程，一个打印奇数，一个打印偶数，轮流输出。但是只用了一个讨巧的方式避开了线程交替获取锁的需求，明显没有答到面试官考察的点上。而且效率较低，如果同一个线程一直抢到锁，而另一个线程一直没有拿到，就会导致线程做很多无谓的空转。那么有没有更好的解决方案，让两个线程严格的交替获取到锁呢？

> 注意：这里的synchronized的锁对象不应该用count变量，因为该变量执行了count++之后，count所指向的对象地址已经变了。

#### 2. 更好的方法：wait/notify

交替获取锁的方案：这种实现方式的原理就是线程1打印之后唤醒线程2，然后让出锁，自己进入休眠状态。因为进入了休眠状态就不会与线程2抢锁，此时只有线程2在获取锁，所以线程2必然会拿到锁。线程2以同样的逻辑执行，唤醒线程1并让出自己持有的锁，自己进入休眠状态。这样来来回回，持续执行直到任务完。代码详见文件`WaitNotifyPrintOddEveWait.java`。



## 9、如何用wait()实现生产者模式？（对应视频7-6）

### 1、为什么要使用生产者消费者模式

在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续处理数据。同样的道理，如果消费者的处理能力大于生产者，那没消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。

### 2、什么是生产者消费者模式

生产者消费者模式（后面简称生产者模式）是非常经典的设计模式之一，而实现生产者模式是wait/notify的典型用途之一。我们将在本小节学习生产者模式，以及如何用wait、notify来实现它。

我面腾讯的时候面到过用wait/notify手写生产者模式的问题，这很重要的一个知识点，很基础，但是可以全面考察候选人的内功。

生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。

#### 1、特点

1. 生产者仅在仓库未满的时候生产，如果仓库满了就停止生产。
2. 消费者仅在仓库有产品时才能消费，如果仓库里面没产品，就等待。
3. 当消费者发现仓库没产品了，会通知生产者去生产。
4.  当生产者生产出可了产品，会通知等待的消费者去消费。

本次是用wait/notify实现，后面还会要求用Condition和BlockingQueue实现生产者消费者模式，原理都是一样的。

#### 2、示意图

![img](https://qqadapt.qpic.cn/txdocpic/0/4729d0175cdf0b2f76c664925d6008c8/0)

#### 3、代码

```java
public class ProducerConsumer {

    public static void main(String[] args) {
        EventStorage eventStorage = new EventStorage();
        Thread producer = new Thread(new Producer(eventStorage));
        Thread consumer = new Thread(new Consumer(eventStorage));
        producer.start();
        consumer.start();
    }
}

// 生产者
class Producer implements Runnable {
    private EventStorage eventStorage;

    public Producer(EventStorage eventStorage) {
        this.eventStorage = eventStorage;
    }

    @Override
    public void run() {
        while (true) {
            eventStorage.put();
        }
    }
}

// 消费者
class Consumer implements Runnable {

    private EventStorage eventStorage;

    public Consumer(EventStorage eventStorage) {
        this.eventStorage = eventStorage;
    }

    @Override
    public void run() {
        while (true) {
            eventStorage.take();
        }
    }
}

// 数据层抽象出来
class EventStorage {
    private int maxLength;
    private LinkedList<Long> linkedList;

    public EventStorage() {
        this.maxLength = 100;
        this.linkedList = new LinkedList<>();
    }

    public synchronized void put() {
        // 队列中放满时，生产者wait()等待消费者唤醒
        while (linkedList.size() == maxLength) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // 没满时就接着放数据
        linkedList.add(new Date().getTime());
        System.out.println("仓库中有了" + linkedList.size() + "个产品");
        notify();
    }

    public synchronized void take() {
        // 队列为空的时候，消费者wait()等待生产者唤醒
        while (linkedList.size() == 0) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // 不为空的时候就取数据
        long date = linkedList.remove();
        System.out.println("拿到了" + date + ",现在仓库还剩下" + linkedList.size());
        notify();
    }
}
```

这里在Storage初始化的时候，配置了容量，所以满了就会阻塞。



## 10、为什么wait()必须在同步代码块中使用？（对应视频7-8）

我们反过来想，如果不要求wait必须在同步块里面，而是可以在之外吊用的话，那么就会有以下代码：

```java
class BlockingQueue {
    Queue<String> buffer = new LinkedList<>();
    
    public void give(String date) {
        buffer.add(data);
        notify();	// since someone may be waiting in take
    }
    
    public String take() throws InterruptedException {
        while (buffer.isEmpty()) {
            wait();
        }
        
        return buffer.remove();
    }
}
```

那么可能会发生以下错误：

1. 消费者线程调用take()并看到了buffer.isEmpty()；
2. 在消费者线程继续wait()之前，生产者线程调用一个完整的give()，也就是buffer.add(data)和notify()；
3. 消费者线程现在调用wait()，但是错过了刚才的notify()；
4. 如果运气不好，即使有可用的数据，但是没有更多生产者生产的话，那么消费者会陷入wait的无限期等待。

一旦你理解了这个问题，解决方案是显而易见的：synchronized用来确保notify永远不会在isEmpty和wait之间被调用。



## 11、为什么线程通信方法wait()/notify()/notifyAll()定义在Object类中？而sleep定义在Thread类里？（对应视频7-8）

**每个对象都可以上锁**，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中，因为**锁属于对象**。

Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。

一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。

每个对象都拥有monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。而不是用当前线程来操作，因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。



## 12、wait方法是属于Object对象的，那么调用Thread.wati()会怎么样？（对应视频7-8）

这里就把Thread当成是一个普通的类，和Object没有区别。

但是这样会有一个问题，那就是线程退出的时候会自动notify()，这会让我们自己设计的唤醒流程受到极大的干扰，所以十分不推荐调用Thread类的wait()，因为这会影响到系统API的正常运行，或者被系统API影响到。



## 13、如何选择用notify还是notifyAll？（对应视频7-3）

Object.notify()可能导致信号丢失这样的正确性问题，而Object.notifyAll()虽然效率不太高（把不需要唤醒的等待线程也给唤醒了），但是其在正确性方面有保障。因此实现通知的一种比较流行的保守性方法是优先使用Object.notifyAll()以保障正确性，只有在有证据表明使用Object.notify()足够的情况下才使用Object.notify()——Object.notify()只有在下列条件全部满足的情况下才能够用于替代notifyAll方法。

条件1：一次通知仅需要唤醒至多一个线程。这一点容易理解，但是光满足这一点还不足以用Object.notify()去替代Object.notifyAll()。在不同的等待线程可能使用不同的保护条件的情况下，Object.notify()唤醒的一个任意线程可能并不是我们需要唤醒的那一个（种）线程。因此，这个问题还需要通过满足条件2来排除。

条件2：相应对象的等待集中仅包含同质等待线程。所谓同质等待线程指这些线程使用同一个保护条件，并且这些线程在Object.wait()调用返回之后的处理逻辑一致。最为典型的同质线程是使用同一个Runnable接口实例创建的不同线程（实例）或者从同一个Thread子类的new出来的多个实例。

> 注意：
>
> Object.notify()唤醒的是其所属对象上的一个任意等待线程。Object.notify()本身在唤醒线程时是不考虑保护条件的。Object.notifyAll()方法唤醒的是其所属对象上的所有等待线程。使用Object.notify()替代Object.notifyAll()时需要确保以下两个条件同时得以满足：
>
> - 一次通知仅需要唤醒至多一个线程；
> - 相应对象上的所有等待线程都是同质等待线程；



## 14、notifyAll之后所有的线程都会再次抢夺锁，那么某个线程抢夺失败怎么办？（对应视频7-8）

继续等待，不会有其他动作，就和等待synchronized的monitor一样。



## 15、用suspend()和resume()来阻塞线程可以吗？为什么？（对应视频7-8）

suspend() 和 resume() 已经不推荐使用，功能类似于wait和notify，但是不释放锁，并且容易引起死锁。



## 16、wait/notify、sleep的异同（方法属于哪个对象？线程状态怎么切换？）？（对应视频7-11）

### 1、相同

1. Wait和sleep方法都可以使线程阻塞，对应线程状态是Waiting或Time_Waiting。 
2. wait和sleep方法都可以响应中断Thread.interrupt()。

### 2、不同

1. wait方法的执行必须在同步方法中进行，而sleep则不需要；
2. 在同步方法里执行sleep方法时，不会释放monitor锁，但是wait方法会释放monitor锁；
3. sleep 方法 短暂 休眠 之后 会 主动 退出 阻塞， 而没有指定时间的 wait 方法则需要被其它线程中断或唤醒后才能退出阻塞；
4. wait()和notify(),notifyAll()是Object类的方法，sleep()和yield()是Thread类的方法；



## 17、在join期间，线程处于那种线程状态？（对应视频7-13）

有书本说是Blocked状态（Java高并发编程详解多线程与架构设计3.8.1），但是这是不对的。

我们自己动手来实验，实践出真知，代码不会骗人。

代码详见`JoinThreadState.java`类。

经过代码演示，我们知道了，答案是Waiting，那么为什么不是Timed_waiting呢，因为join的时候无法预料等待时间是多少。



## 18、yield和sleep的区别？（对应视频7-15）

yield和sleep区别是，sleep期间线程调度器不会去调度该线程，而yield方法时只是让线程释放出自己的CPU时间片，线程依然处于就绪状态，随时可能再次被调度。



## 19、守护线程和普通线程的区别？（对应视频8-3）

User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了，这是因为没有了“被守护者“，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。



## 20、我们是否需要给线程设置为守护线程？（对应视频8-3）

我们通常不应把自己的线程设置为守护线程，因为设置为守护线程是很危险的。比如线程正在访问如文件、数据库的时候，所有用户线程都结束了，那么守护线程会在任何时候甚至在一个操作的中间发生中断，所以守护线程永远不应该去访问固有资源。



## 21、为什么程序设计不依赖于线程优先级？（对应视频8-4）

由于优先级最终是由线程调度器来决定调度方案的，所以优先级高并不能保证就一定比优先级低的先运行；并且如果优先级设置得不合适，可能会导致线程饥饿等问题（优先级低的线程始终得不到运行），所以通常而言，我们不必要设置线程的优先级属性，保持默认的优先级就可以。

给线程设置的优先级的意图是希望高优先级的线程被优先执行，但是线程优先级的执行情况是高度依赖于操作系统的，Java的10个线程的优先级会被映射到操作系统的优先级上，不同的操作系统的优先级个数也许更多，也许更少。

例如， Windows 有7 个优先级别，对应关系如下：

![img](https://qqadapt.qpic.cn/txdocpic/0/5fc0c0206ce83bb730b5601932bb0fe5/0?_type=png)

但是在Oracle 为Linux 提供的Java 虚拟机中， 线程的优先级被忽略——所有线程具有相同的优先级；Solaris中有2的32次这么多个优先级级别。所以可以看出，“**优先级”这个属性，会随着操作系统的不同而变化，这是很不可靠的**。

刚才仅仅是优先级不可靠的第一个原因，还有第二个原因：

**优先级可能会被系统自行改变**。例如，在Windows系统中存在一个称为“优先级推进器”（Priority Boosting，当然它可以被关闭掉）的功能，它的大致作用就是当系统发现一个线程执行得特别“勤奋努力”的话，可能会越过线程优先级去为它分配执行时间。因此，我们不能在程序中通过优先级来完全准确地判断一组状态都为Ready的线程将会先执行哪一个。

因此我们不应该把程序的正确性依赖于优先级。



## 22、讲讲Java异常体系？（对应视频5-9）

![img](https://qqadapt.qpic.cn/txdocpic/0/8eb35cdd4e9e99873c997fa917a6bf1f/0?_type=jpeg)

需要注意的是,所有的异常都是由 Throwable继承而来,但在下一层立即分解为两个分支:Eror和 Exception。

Eror类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误,除了通告给用户,并尽力使程序安全地终止之外,再也无能为力了。这种情况很少出现。

在设计Java程序时,需要关注 Exception层次结构。这个层次结构又分解为两个分支：一个分支派生于 Runtime Exception;另一个分支包含其他异常。

划分两个分支的规则是:由程序错误导致的异常属于 RuntimeException;而程序本身没有问题,但由于像I/O错误这类问题导致的异常属于其他异常。

派生于 RuntimeException的异常包含下面几种情况：

> 错误的访问类型
>
> 数组访问越界
>
> 访问空指针
>
> ......

不是派生于 RuntimeException的异常包括：

> 试图在文件尾部后面读取数据。
>
> 试图打开一个不存在的文件。
>
> 试图根据给定的字符串查找 Class对象,而这个字符串表示的类并不存在。
>
> ......

如果出现 RuntimeException异常,那么就一定是你的问题”是一条相当有道理的规则。

应该通过检测数组下标是否越界来避免 ArraylndexOutOfBounds Exception异常;应该通过在使用变量之前检测是否为null来杜绝 NullPointerException异常的发生。

但是如何处理不存在的文件呢?难道不能先检查文件是否存在再打开它吗?嗯,这个文件有可能在你检査它是否存在之前就已经被删除了。因此,“是否存在”取决于环境,而不只是取决于你的代码。

Java语言规范将派生于Eror类或 RuntimeException类的所有异常称为非受查(unchecked)异常,所有其他的异常称为受查( checked)异常。这是两个很有用的术语,编译器将核查是否为所有的受查异常提供了异常处理器。

注释: RuntimeException这个名字很容易让人混淆。实际上,现在讨论的所有错误都发生在运行时。



## 23、实际工作中，如何处理全局异常？（对应视频9-3）

### 1、给程序统一设置

先自己实现UncaughtExceptionHandler接口，在uncaughtException(Thread t, Throwable e)的实现上，根据业务需要可以有不同策略，最常见的方式是把错误信息写入日志，或者重启线程、或执行其他修复或诊断：

代码演示：`UncaughtExceptionHandler.java`类

捕获器1捕获了异常在MyThread-1的异常：java.lang.RuntimeException，也会打印出异常栈信息，但是这都是我们控制的，如果我们把UncaughtExceptionHandler类的logger部分注释掉，那么异常堆栈就不打印。

我们就可以用以上的方法，来处理未捕获异常，来增强健壮性。以后，如果我们用到的第三方库在线程中抛出了未捕获异常，我们也可以从容面对，捕获异常并处理了。

在平时的工作中，这种设计方式是比较常见的，尤其是那种异步执行方法，比如Google的guavatoolkit就提供了EventBus，在EventBus中事件源和实践的subscriber两者借助于EventBus实现了完全的解耦合，但是在subscriber执行任务时有可能会出现异常情况，EventBus同样也是借助于一个ExceptionHandler进行回调处理的。

### 2、给每个线程或者线程池单独设置

刚才我们是给整个程序设置了默认的UncaughtExceptionHandler，这是通常的做法。当然，如果业务有特殊需求，我们也可以给某个线程或者线程池指定单独的特定的UncaughtExceptionHandler，这样可以更精细化处理。



## 24、为什么异常需要全局处理？不处理行不行？（对应视频9-3）

不处理是不行的，因为否则异常信息会抛给前端，这会让重要的信息泄露，不安全。只要是未处理异常，我们返回给前端就是简单的一句话“意外错误”，而不应该把异常栈信息也告诉前端，否则会被白帽子、黑客利用。



## 25、run方法是否可以抛出异常？如果抛出异常，线程的状态会怎么样？（对应视频9-1）

run方法不能抛出异常，如果运行时发生异常，默认行为是打印异常堆栈，线程停止运行，状态变成Terminated，但是不影响主线程的运行。



## 26、一共有哪几种线程安全问题？（对应视频10-3、10-6~10-12）

**1、运行结果错误**

例如a++多线程下出现结果小于累加次数。

**2、对象发布和初始化的时候的安全问题**

1. 方法返回一个private对象（private的本意是不让外部访问）
2. 还未完成初始化（构造函数没有完全执行完毕）就把对象提供给外界，比如：
   1. 在构造函数中未初始化完毕就this赋值
   2. 隐式溢出--注册监听事件
   3. 构造函数中运行线程

**3、死锁等问题**



## 27、哪些场景需要额外注意线程安全问题？（对应视频10-13）

**1、访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等；**

**2、所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题**

1. read-modify-write操作：一个线程读取了共享数据，并在此基础上更新该数据，比如i++；
2. check-then-act操作：一个线程读取了一个共享数据，并在此基础上决定其下一个操作；

**3、不同数据之间存在捆绑关系的时候**

**4、我们使用其它类的时候，如果对方没有声明自己是线程安全的，那么大概率会存在并发问题的隐患**



## 28、为什么多线程会带来性能问题？（对应视频10-14）

体现在两个方面：线程的**调度**和**协作**，这两个方面通常相辅相成，也就是说，**由于线程需要协作，所以会引起调度**。

### 1、调度：上下文切换

什么时候会需要线程调度呢?当可运行的线程数超过了CPU核心数，那么操作系统就要调度线程，以便于让每个线程都有运行的机会。

调度会引起上下文切换。

例如当某个线程运行Thread.sleep(1000);的时候，线程调度器就会让当前这个线程阻塞，然后往往会让另一个正在等待CPU资源的线程进入可运行状态，这里会产生“上下文切换”，这是一种比较大的开销，有时用于上下文切换的时间甚至比线程执行的时候更长。

通常而言，一次上下文切换所带来的开销大约在5000~10000个时钟周期，大约几微秒，看似不起眼，其实已经是不小的性能损耗了。

#### 1、什么是上下文

同学们如果对操作系统这门课熟悉，就比较了解上下文，不过我担心小伙伴们可能不熟悉操作系统，所以我在这里补充下“上下文”的知识：

上下文是指某一时间点 CPU 寄存器和程序计数器的内容。寄存器是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。

稍微详细描述一下，上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：（1）挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处，（2）在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复，（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。

#### 2、缓存开销

除了刚才提到的上下文切换带来的直接开销外，还需要考虑到间接带来的缓存失效的问题。我们知道程序有很大概率会访问刚才访问过的数据，所以CPU为了加快执行速度，会根据不同算法，把常用到的数据缓存到CPU内，这样以后再用到该数据时，可以很快使用。

但是现在上下文被切换了，也就是说，CPU即将执行不同的线程的不同的代码，那么原本缓存的内容有极大概率也没有价值了。这就需要CPU重新缓存，这导致线程在被调度运行后，一开始的启动速度会有点慢。

为此，线程调度器为了避免太频繁的上下文切换带来的开销过大，往往会给每个被调度到的线程设置一个“最小执行时间”，这样就把上下文切换的最小阈值提高，减少上下文切换的次数，从而提高性能（但是当然，也降低了响应性）。

#### 3、何时会导致密集的上下文切换

如果程序**频繁的竞争锁**，或者由于**IO读写**等原因导致**频繁阻塞**，那么这个程序就可能需要更多的上下文切换，这也就导致了更大的开销。

### 2、协作：内存同步

线程之间如果使用共享数据，那么为了避免数据混乱，肯定要使用同步手段，为了数据的正确性，同步手段往往会**禁止编译器优化、使cpu内的缓存失效**等手段，这显然带来了额外开销，因为减少了原本可以进行的优化。



## 29、什么是多线程的上下文切换？（对应视频10-14）

上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：

（1）挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处；

（2）在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复；

（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程；



## 30、Java代码如何一步步转换，最终被cpu执行？（对应视频12-3）

![img](https://qqadapt.qpic.cn/txdocpic/0/1b21d707bb96e792bfa2763456f4724b/0?_type=png)

1. 最开始，我们编写的Java代码，是*.java文件

2. 在编译（javac命令）后，从刚才的*.java文件会变出一个新的Java字节码文件（*.class）

3. JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令

4. 机器指令可以直接在CPU上执运行，也就是最终的程序执行



## 31、单例模式的作用和适用场景？（对应视频13-9~13-13）



## 32、重排序的实例：单例模式多种写法、单例和高并发的关系（重要，真实面试高频考题，重点双重检查模式的volatile）？（对应视频13-11）

## 33、单例模式各种写法的适用场景？（对应视频13-13）

## 34、饿汉式的缺点？（对应视频13-13）

## 35、懒汉式的缺点？（对应视频13-13）

## 36、为什么要用double-check？不用就不安全吗？（对应视频13-11）

## 37、为什么双重检查模式要用volatile？（对应视频13-11）

## 38、应该如何选择，用哪种单例的实现方方案最好？（对应视频13-13）

## 39、讲一讲什么事Java内存模型？（对应视频12、13章）

## 40、什么事happens-before？（对应视频12-13~12-15）

## 41、Happens-before规则有哪些？（对应视频12-14）

## 42、讲讲volatile关键字？（对应视频13-1~13-5）

## 43、volatile和synchronized的异同？（对应视频13-5）

## 44、什么是内存可见性问题？（对应视频12-9~12-11）

## 45、主内存和本地内存的关系？（对应视频12-12）

## 46、什么是原子操作？（对应视频13-7）

## 47、Java中的原子操作有哪些？（对应视频13-7）

## 48、long和double的原子性你了解吗？（对应视频13-8）

## 49、生成对象的过程是不是原子操作？（对应视频13-11）

## 50、写一个必然死锁的例子？（对应视频14-5）

## 51、生产中什么场景下会发生死锁？（对应视频14-6、14-7）

## 52、发生死锁必然满足哪些条件？（对应视频14-8）

## 53、如何用工具定位死锁？（对应视频14-9、14-10）

## 54、有哪些解决死锁的策略？（对应视频14-11~14-15）

## 55、讲一讲经典的哲学家就餐问题（经典名称叫刀叉问题、吃面问题）？（对应视频14-12~14-14）

## 56、实际开发中如何避免死锁？（对应视频14-16、14-17）

## 57、什么事活跃性问题？活锁、饥饿和死锁有什么区别？（对应视频14-18~14-21）