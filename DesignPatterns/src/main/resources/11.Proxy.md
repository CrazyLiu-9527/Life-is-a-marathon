## 代理模式
代理模式的定义：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。
#### 1.静态代理
通过手动创建代理类来隐藏具体实现类的实现细节，并且可以在执行方法前后增加一部分别的逻辑
**文件解析**

> - BuyHouse 接口
> - BuyHouseImpl 产生动作的类，实现BuyHouse
> - BuyHouseProxyHandler 代理类，实现BuyHouse，用于执行BuyHouseImpl中的动作，并且通常在执行动作的前后增肌一些其他逻辑

#### 2.动态代理
- 动态代理，我们不在显示的编写代理类，而是通过读取分析类的二进制字节码来动态生成代理类，实质上还是生成了一个中间代理类，代理类实现了传入接口的相关方法。
因此在通过代理类调用方法的过程中，会直接调用代理类实现的方法，这个过程中会调用invoke方法。
- 读取字节码的过程是通过asm完成的，asm是一个体积很小的类库，可以直接读取二进制字节码
##### 2.1 jdk动态代理
- 实现InvocationHandler，传入需要代理的接口类，生成动态代理类
##### 2.2 cglib动态代理
- 摆脱了jdk动态代理只能实现接口的桎梏，但是cglib依然不能继承final类
- 相比jdk动态代理要更方便
#### 3.spring的aop
spring中的aop实际上用的就是动态代理，通过定义切点和切面来织入需要的逻辑。



**JDK和CGLib动态代理分析**

自Java 1.3以后，Java提供了动态代理技术，允许开发者在运行期创建接口的代理实例，后来这项技术被用到了Spring的很多地方。JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑（如：我们在方法执行前后打印的日志，本文只是为了演示，实际的应用一般不会只是简单的打印日志的），并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起。

**JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例哪？答案就是CGLib。**

**CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成**。CGLIB通过继承方式实现代理，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。



**JDK和CGLib动态代理区别**

1、JDK动态代理具体实现原理：

**通过实现InvocationHandler接口创建自己的调用处理器；**

通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；

通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；

通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；

JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，Spring通过Java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。

2、CGLib动态代理：

**利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。**

3、两者对比：

**JDK动态代理是面向接口的。**

**CGLib动态代理是通过字节码底层继承要代理类来实现，因此如果被代理类被final关键字所修饰，会失败。**

4、使用注意：

**如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；**

**如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。**

**JDK和CGLib动态代理性能对比**

关于两者之间的性能的话，网上有人对于不通版本的jdk进行测试，经过多次试验，测试结果大致是这样的，**在1.6和1.7的时候，JDK动态代理的速度要比CGLib动态代理的速度要慢**，但是并没有教科书上的10倍差距，**在JDK1.8的时候，JDK动态代理的速度已经比CGLib动态代理的速度快很多了**，但是JDK动态代理和CGLIB动态代理的适用场景还是不一样的哈！