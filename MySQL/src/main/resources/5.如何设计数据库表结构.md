## 第四章 MySQL数据库结构优化
### 一 数据库结构优化介绍
良好的数据库逻辑设计和物理设计是数据库获得高性能的基础

+ 查询语句尽量简单
    + 反范式化设计 能加快一些语句的查询速度 也可能会影响一些其他的语句性能
    
#### 数据库结构优化的目的
+ 减少数据冗余（不代表没有冗余）
+ 尽量避免数据维护中出现更新，插入和删除异常
    + 插入异常：如果表中的某个实体随着另一个实体而存在
    + 更新异常：如果更改表中的某个实体的单独属性时，需要对多行进行更新
    + 删除异常：如果删除表中某一实体则会导致其他实体的消失
+ 节约数据存储空间
+ 提高查询效率
### 二 数据库结构设计
#### 数据库结构设计的步骤
1. 需求分析：全面了解产品设计的存储需求
    + 存储需求
    + 数据处理需求
    + 数据的安全性和完整性
2. 逻辑设计：设计数据的逻辑存储结构
    + 数据实体之间的逻辑关系，解决数据冗余和数据维护异常
3. 物理设计：根据所使用的数据库特点进行表结构设计
    + 关系型数据库：Oralce，SQLServer，MySQL，postgresSQL
    + 非关系型数据库： mongo,Redis,Hadoop
4. 维护优化：根据实际情况对索引、存储结构等进行优化

#### 数据库设计范式
> 设计出没有数据冗余和数据维护异常的数据库结构

#### 数据库设计的第一范式
+ 数据库表中的所有字段都只具有单一属性
+ 单一属性的列是由基本的数据类型所构成的
+ 设计出来的表都是简单的二维表

#### 数据库设计的第二范式
+ 要求一个表中只有具有一个业务主键
    
    >也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系

#### 数据库设计的第三范式
+ 每一个非主属性既不部分依赖于也不传递依赖于业务主键
    
    >也就是在第二范式的基础上消除了非主属性对主键的传递依赖

### 三 需求分析及逻辑设计
#### 需求说明
按下面的需求设计一个电子商务网站的数据库结构
1. 本网站只销售图书类商品
2. 需要具有以下功能
    + 用户登录
    + 用户管理
    + 商品展示
    + 商品管理
    + 供应商管理
    + 在线销售

#### 需求分析及逻辑设计
##### 用户登录及用户管理功能
+ 用户必须注册并登录系统才能进行网上交易
用户名作为业务主键(？？？)
+ 同一时间一个用户只能在一个地方登录
+ 用户属性：{用户名，密码，手机号，姓名，注册日期，在线状态，出生日期} 用户名为主键
   > 只有一个业务主键，一定是符合第二范式
   > 没有属性和业务主键存在传递依赖关系，符合第三范式
   
##### 商品展示及商品管理功能
+ 商品信息:{商品名称，分类名称，出版社名称，图书价格，图书描述，作者} 
    >商户名称和分类名称为主键 不满足第二范式
    + 商品信息：{商品名称，出版社名称，图书价格，图书描述，作者} 
    + 分类信息：{分类名称，分类描述}
    + 商品分类（对应关系表）：{商品名称，分类名称}
    
##### 供应商管理功能
+ 供应商信息：{出版社名称，地址，电话，联系人，银行账号} 出版社信息PERMARY KEY

##### 在线销售功能
+ 在线销售：{订单编号，下单用户名，下单日期，订单金额，订单商品分类，订单商品名，订单商品单价，订单商品数量，支付金额，物流单号}
    1. 只有一个业务主键，符合第二范式
    2. 订单商品单价，订单商品数量，订单编号 存在着传递关系，不符合第三范式
    3. 数据冗余=>订单商品信息和订单信息表中的数据
+ 拆分
    + 订单表：{订单编号，下单用户名，下单日期，支付金额，物流单号}
    + 订单商品关联表：{订单编号，订单商品分类，订单商品名，商品数量}
+ 编写SQL查询出每一个用户的订单总金额
```sql
select 下单用户名,sum(d.商品价格*b.商品数量) from 订单表 a join 订单商品关联表 b on a.订单编号=b.订单编号 join 商品分类关联表 c on c.商品名称=b.商品名称 and c.分类名称=b.订单商品分类 join 商品信息表 d on d.商品名称=c.商品名称 group by 下单用户名
```
1. 关联表越多性能越差
2. 如果商品价格变动那会发生什么变化

> 假设下单用户就是商品的收货人，我们在发货前一定要查询出每个订单的下单人信息，而这些信息全部记录在用户信息表中
>
> 编写SQL查询出下单用户和订单详情
> ```sql
> select a.订单编号, e.用户名, e.手机号, d.商品名称, c .商品数量, d.商品价格 join 商品分类关联表 c on c .商品名称= b.商品名称 join 商品信息表 d on d.商品名称= c.商品名称 join 用户信息表 e on e.用户名= a.下单用户名
> ```

完全符合范式化的设计有时并不能得到良好的SQL查询性能

### 四 需求分析及逻辑设计-反范式化设计
#### 什么叫做反范式化设计
反范式化是针对范式化而言的，在前面介绍了数据库设计的范式，所谓的反范式化就是为了性能和读取效率的考虑而适当的对数据库设计范式的要求进行违反，而允许存在少量的数据冗余，换句话来说反范式化就是使用空间来换取时间

#### 图书在校销售网站数据库的反范式化改造

+ 原来的表：
    + 商品信息：{商品名称，出版社名称，图书价格，图书描述，作者}
    + 分类信息：{分类名称，分类描述}
    + 商品分类关系：{商品名称，分类名称}
+ 改造后的表
     + 商品信息：{商品名称，分类名称，出版社名称，图书价格，图书描述，作者}
     + 分类信息：{分类名称，分类描述}
     
+ 原来的表：
    + 订单表：{订单编号，下单用户名，下单日期，支付金额，物流单号}
    + 订单商品关联表：{订单编号，订单商品分类，订单商品名，商品数量}
+ 改造后的表：
    + 订单表：{订单编号，下单用户名，手机号，下单日期，支付金额，物流单号，订单金额}
    + 订单商品关联表：{订单编号，订单商品分类，订单商品名，商品数量，商品单价}
    
#### 范式化改造后的查询
+ 编写SQL查询出每一个用户的订单总金额
```sql
select 下单用户名,sum(订单金额) from 订单表 group by 下单用户名
```
+ 编写SQL查询出下单用户和订单详情
```sql
select a.订单编号, a.用户名, a.手机号, b.商品名称, b.商品单价, b.商品数量 from 订单表 a join 订单商品关联表 b on a.订单编号=b.订单编号
```
#### 总结
+ 不能完全按照范式化的要求进行设计
+ 考虑以后如何使用表

### 五 范式化设计与反范式化设计优缺点

#### 范式化设计的优缺点
+ 优点：
    + 可以尽量的减少数据冗余
        + 数据表更新快体积小
    + 范式化的更新操作比反范式化更快
    + 范式化的表通常比反范式化更小
+ 缺点：
    + 对于查询需要对多个表进行关联
    + 更难进行索引优化
    
#### 反范式化设计的优缺点
+ 优点：
    + 可以减少表的关联
    + 可以更好的进行索引优化
+ 缺点：
    + 存在数据冗余及数据维护异常
    + 对数据的修改需要更多的成本

### 六 物理设计介绍

#### 物理设计设计的内容
+ 定义数据库、表及字段的命名规范
+ 选择合适的存储引擎
+ 为表中的字段选择合适的数据类型
+ 建立数据库结构

#### 定义数据库、表及字段的命名规范
+ 数据库、表及字段的命名要遵守可读性原则
+ 数据库、表及字段的命名要遵守表意性原则
+ 数据库、表及字段的命名要遵守长名原则

#### 选择合适的存储引擎

| 存储引擎 | 事务| 锁粒度 | 主要应用 | 忌用 |
|---|---|---|---|---|
|My
ISAM|不支持|支持并发插入的表级锁|SELECT,INSERT|读写操作频繁|
|MRG_MYISAM|不支持|支持并发插入的表级锁|分段归档，数据仓库|全局查找过多的场景|
|Innodb|支持|支持MVCC的行级锁|事务处理|无|
|Archive|不支持|行级锁|日志记录，只支持insert，select|需要随机读取，更新，删除|
|Ndb|支持|行级锁|高可用性|大部分应用|

### 七 物理设计-数据类型的选择
#### 为表中的字段选择合适的数据类型
> 当一个列可以选择多种数据类型时，应该优先考虑素质类型，其次是日期或二进制类型，最后是支付类型。对于相同级别的数据类型，应该优先选择占用空间小的数据类型。

#### 如何选择正确的整数类型

| 列类型    | 存储空间 | SINGED                                                       | UNSINGED                             |
| --------- | -------- | ------------------------------------------------------------ | ------------------------------------ |
| tinyint   | 1字节    | -128~127(-2^7~(2^7)-1)                                       | 0~255((2^8)-1)                       |
| smallint  | 2字节    | -32768~32767(-2^15~(2^15)-1)                                 | 0~65535((2^16)-1)                    |
| mediumint | 3字节    | -8388608~8388607(-2^23~(2^23)-1)                             | 0~16777215((2^24)-1)                 |
| int       | 4字节    | -2147483648~2147483647(-2^31~(2^31)-1)                       | 0~4294967295((2^32)-1))              |
| bigint    | 8字节    | -9223372036854775808<br/>~9223372036854775807(-2^63~(2^63)-1) | 0<br>~18446744073709551615((2^64)-1) |

#### 如何选择正确的实数类型
| 列类型  | 存储空间                             | 是否精确类型 |
| ------- | ------------------------------------ | ------------ |
| FLOAT   | 4个字节                              | 否           |
| DOUBLE  | 8个字节                              | 否           |
| DECIMAL | 每4个字节存9个数字，小数点占一个字节 | 是           |

#### 如何选择VARCHAR和CHAR类型
##### VARCHAR类型的存储特点
> 定义的都是**字符长度**不是字节长度，UTF8为例，一个字符占3个字节;
+ varchar用于存储边长字符串，只占必要的存储空间
+ 列的最大长度小于255则只占用一个额外字节用于记录字符串长度
+ 列的最大长度大于255这要占用两个额外字节用于记录字符串长度
+ 正因为两个字节记录字符串长度，varchar最大长度为 65535，最大存储字符数量(defalut null 则 65535-2-1=65532，not null 则 65535-2=65533)

##### VARCHAR长度的选择问题
+ 使用最小的符合需求的长度
+ varchar(5)和varchar(200)存储'MySQL'字符串性能不同

##### VARCHAR的适用场景
+ 字符串列的最大长度比平均长度大很多
+ 字符串列很少被更新
+ 使用了多字节字符集存储字符串

##### CHAR类型的存储特点
+ CHAR类型是定长的
+ 字符串存储在CHAR类型的列中会删除末尾的空格
+ CHAR类型的最大宽度为255

##### CHAR的适用场景
+ CHAR类型适合存储所长度近似的值
+ CHAR类型适合存储短字符串
+ CHAR类型适合存储经常更新的字符串列

### 八 物理设计-如何存储日期类型
#### DATETIME类型
>以YYYY-MM-DD HH:MM:SS[.fraction] 格式存储日期时间
>datetime = YYYY-MM-DD HH:MM:SS
>datetime(6) = YYYY-MM-DD HH:MM:SS.fraction(微秒需要datetime(6)) 
>DATETIME类型与时区无关，占用8个字节的存储空间
>时间范围1000-01-01 00:00:00到9999-12-31 23:59:59

#### 类型

>存储了由格林尼治时间1970年1月1日到当前时间的秒数
>以YYYY-MM-DD HH:MM:SS.[fraction]的格式显示，占用4个字节(timestamp(6))
>时间范围1970-01-01到2038-01-19
+ timestamp类型显示依赖于所指定的时区
+ 在行的数据修改时可以自动修改timestamp列的值

#### DATE类型和TIME类型
##### DATE类型的有点:
1. 占用的字节数比使用字符串（8）、datetime（8）、int（4）存储要少，使用dete类型只需要3个字节
2. 使用Date类型还可以利用日期时间函数进行日期之间的计算
    + date类型用于保存1000-01-01到9999-12-31之间的日期

##### TIME类型
time类型用于存储时间数据，格式为HH:MM:SS

#### 存储日期时间数据的注意事项
+ 不要使用字符串类型来存储日期时间数据
日期时间类型通常比字符串占用的存储空间小
日期时间类型在进行查找过滤时可以利用日期来进行对比
日期时间类型还有丰富的处理函数，可以方便的对时期类型进行日期计算

+ 使用INT存储日期时间不如使用TIMESTAMP类型（***这是视频作者说的，个人并不觉得***）

### 九 物理设计-总结
#### 物理设计
+ 存储空间
+ 存储引擎
+ 数据类型
+ 没有特殊要求推荐使用INNODB
+ 为表中的每个列选择合适的类型
+ 如何选择表的主键
    + 主键应该尽可能的小
    + 主键应该是顺序增长的<br>
    增加数据的插入效率
    + Innodb的主键和业务主键可以不同（为了业务主键的唯一性，可以使用唯一索引）
+ 数据库结构
    + 查询性能要求
    + 范式化要求